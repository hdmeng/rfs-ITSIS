import csv
import logging
import os
import sys
import time
import timeit
from datetime import datetime
from datetime import timedelta
from os import path

import googlemaps
import MySQLdb
import numpy as np
import pandas as pd
import pytz
import sqlalchemy as sa
import sqlalchemy.dialects.mysql as samysql

import dataframeutility
import gtfsutility
import maputility


class TableUtility:
    """Collection of functions to generate Task 1 - 3 tables.

    Attributes:
        agencyID: An integer indicator of the agency whose table are being
            calculated.
        routeID: A string name of a specific route to calculate tables for.
        static_feed: A dictionary of DataFrames representing the agency's
            static GTFS feeds.
        trip_update_feed: A FeedMessage instance of the agency's Trip Update
            real-time GTFS feed.
        alert_feed: A FeedMessage instance of the agency's Alert real-time GTFS
            feed.
        vehicle_position_feed: A FeedMessage instance of the agency's Vehicle
            Position real-time GTFS feed.
        should_refresh: A boolean value of whether to override existing data.
        tables: A dictionary of DataFrames for the generated Task 1 - 3 tables.
        trip2pattern: A dictionary mapping trip_ids to pattern_ids.
        trip2vehicle: A dictionary mapping trip_ids to veh_ids.
        pattern2shape: A dictionary mapping pattern_ids to shape_ids.
    """
    tables = {}
    trip2pattern = {}
    trip2vehicle = {}
    pattern2shape = {}

    def __init__(self, agencyID, routeID, static_feed, checksum,
                 trip_update_feed, alert_feed, vehicle_position_feed, datapath,
                 should_refresh):
        self.agencyID = agencyID
        self.routeID = routeID
        self.static_feed = static_feed
        self.checksum = checksum
        self.trip_update_feed = trip_update_feed
        self.alert_feed = alert_feed
        self.vehicle_position_feed = vehicle_position_feed
        self.datapath = datapath
        # self.should_refresh = should_refresh
        # TODO(erchpito) change this back
        self.should_refresh = True

    # MARK: HELPER FUNCTIONS

    @staticmethod
    def datetimeFromHMS(timestamp):
        """Converts a timestamp string into a datetime instance.

        An hours hand of '99' will be ignored, while any hours hand a general
        24-hour clock will convert the overflow into days.

        Args:
            timestamp: An HH:MM:SS formatted string.

        Returns:
            A datetime instance of the timestamp
        """
        delay = timedelta(seconds=0)
        if int(timestamp[:2]) == 99:
            # TODO(erchpito) ignore these sets
            # RESPONSE: only for VTA and BART
            pass
        elif int(timestamp[:2]) >= 24:
            timestamp = str(int(timestamp[:2]) - 24) + timestamp[2:]
            delay = timedelta(days=1)

        o_time = time.strptime(timestamp, '%H:%M:%S')
        n_time = datetime.now().replace(hour=o_time.tm_hour,
                                        minute=o_time.tm_min,
                                        second=o_time.tm_sec,
                                        microsecond=0)
        return n_time + delay

    def generate_table(self, table_name, table, setup_row_func, typing,
                       refresh, rows=None, entities=None, row_collector=None, clear=True):
        """Loads the requested table into self.tables.

        If possible, the table will be fetched from a database or
        from a local file. Otherwise, the table will be generated by running
        the setup_row_func over the initial data rows or real-time GTFS feed
        entities, with the result written to a database or a local file.

        Args:
            table_name: A string to name the table.
            table: A DataFrame instance.
            setup_row_func: A setup function that runs on each row or entity
                to generate new rows for the table.
            rows: A DataFrame instance to supply initial data for the setup
                function.
            entities: A FeedMessage instance to supply real-time GTFS feed
                entities for the setup function.
        """
        generate = True
        if (dataframeutility.can_read_dataframe(table_name, self.datapath) and
                not refresh):
            self.tables[table_name] = dataframeutility.read_dataframe(
                table_name, self.datapath)
            self.tables[table_name] = self.tables[table_name].loc[
                (self.tables[table_name]['agency_id'] == self.agencyID)]
            if not self.tables[table_name].empty:
                generate = False
        if generate:
            if row_collector is None:
                self.tables[table_name] = table

            start = timeit.default_timer()

            if rows is not None:
                for i, row in rows.iterrows():
                    setup_row_func(i, row)
            elif entities is not None:
                for entity in entities:
                    setup_row_func(entity)

            if row_collector is not None:
                self.tables[table_name] = pd.DataFrame(row_collector)

            stop = timeit.default_timer()
            logging.debug('runtime: {0}'.format(stop - start))

            dataframeutility.write_dataframe(
                self.tables[table_name], table_name, self.datapath, typing,
                self.agencyID, clear)
        logging.debug('SUCCESS finished with {0}'.format(table_name))

    # MARK: TASK 1

    def agency_definition(self, metadata):
        return sa.Table(
            'Agency', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('agency_name', samysql.VARCHAR(255), nullable=False),
            sa.Column('agency_url', samysql.VARCHAR(255), nullable=False),
            sa.Column('agency_timezone', samysql.SMALLINT(6), nullable=False, key='agency_timezone'),
            sa.Column('agency_lang', samysql.VARCHAR(255), nullable=False),
            sa.Column('agency_phone', samysql.VARCHAR(255), nullable=False),
            sa.Column('timezone_name', samysql.VARCHAR(45), nullable=False)
            )

    def agency(self, refresh=True):
        """Loads the Agency table into self.tables
        Setups arguments for self.generate_table to match the description of
        the Agency table as described in Task 1.
        """
        table_name = 'Agency'
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'agency_name': samysql.VARCHAR(255),
                  'agency_url': samysql.VARCHAR(255),
                  'agency_timezone': samysql.SMALLINT(6),
                  'agency_lang': samysql.VARCHAR(255),
                  'agency_phone': samysql.VARCHAR(255),
                  'timezone_name': samysql.VARCHAR(45)
                  }
        table = pd.DataFrame(
            index=np.r_[0:len(self.static_feed['agency'].index)],
            columns=typing.keys())

        def agency_row_func(i, row):
            table.set_value(i, 'agency_id', int(self.agencyID))
            table.set_value(i, 'agency_name', str(row['agency_name']))
            table.set_value(i, 'agency_url', str(row['agency_url']))
            timezone = pytz.timezone(row['agency_timezone'])
            offset = timezone.localize(
                datetime(2000, 1, 1), is_dst=False).strftime('%z')
            table.set_value(i, 'agency_timezone', int(offset))
            table.set_value(i, 'agency_lang', dataframeutility.optional_field(
                i, 'agency_lang', self.static_feed['agency'], default='N/A'))
            table.set_value(i, 'agency_phone', dataframeutility.optional_field(
                i, 'agency_phone', self.static_feed['agency'], default='N/A'))
            table.set_value(i, 'timezone_name', row['agency_timezone'])

        dataframeutility.setup_table(table_name, self.datapath, self.agency_definition)
        self.generate_table(table_name, table, agency_row_func, typing,
                            refresh, rows=self.static_feed['agency'])

    def routes_definition(self, metadata):
        return sa.Table(
            'Routes', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('route_short_name', samysql.VARCHAR(255), nullable=False, primary_key=True),
            sa.Column('route_dir', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('route_type', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('route_long_name', samysql.VARCHAR(255), nullable=False, default='N/A'),
            sa.Column('route_desc', samysql.VARCHAR(255), nullable=False, default='N/A'),
            sa.Column('route_url', samysql.VARCHAR(255), nullable=False, default='N/A'),
            sa.Column('route_color', samysql.VARCHAR(255), nullable=False, default='FFFFFF'),
            sa.Column('route_text_color', samysql.VARCHAR(255), nullable=False, default='000000'),
            sa.Column('route_id', samysql.VARCHAR(255), nullable=False, default='000000'),
            sa.Column('version', samysql.VARCHAR(255), nullable=False, primary_key=True)
            )

    def routes(self, refresh=True):
        """Loads the Routes table into self.tables.

        Setups arguments for self.generate_table to match the description of
        the Routes table as described in Task 1.
        """
        table_name = 'Routes'
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'route_short_name': samysql.VARCHAR(255),
                  'route_dir': samysql.INTEGER(10, unsigned=True),
                  'route_type': samysql.INTEGER(10, unsigned=True),
                  'route_long_name': samysql.VARCHAR(255),
                  'route_desc': samysql.VARCHAR(255),
                  'route_url': samysql.VARCHAR(255),
                  'route_color': samysql.VARCHAR(255),
                  'route_text_color': samysql.VARCHAR(255),
                  'route_id': samysql.VARCHAR(255),
                  'version': samysql.VARCHAR(255)
                  }
        table = None
        row_collector = []

        def routes_row_func(i, row):

            # We check the trips table for the directions present in each route
            # and generate a row for each of those directions.

            # TODO(erchpito) direction_id is an optional field in trips
            for direction_id in self.static_feed['trips'].loc[
                self.static_feed['trips']['route_id'] ==
                    row['route_id']]['direction_id'].unique():
                new_row = {}
                new_row['agency_id'] = int(self.agencyID)
                new_row['route_short_name'] = dataframeutility.optional_field(
                    i, 'route_short_name', self.static_feed['routes'],
                    default=self.static_feed['routes'].iloc[i]
                    ['route_long_name'])
                new_row['route_dir'] = int(direction_id)
                new_row['route_type'] = int(row['route_type'])
                new_row['route_long_name'] = dataframeutility.optional_field(
                    i, 'route_long_name', self.static_feed['routes'],
                    default='N/A')
                new_row['route_desc'] = dataframeutility.optional_field(
                    i, 'route_desc', self.static_feed['routes'], default='N/A')
                new_row['route_url'] = dataframeutility.optional_field(
                    i, 'route_url', self.static_feed['routes'], default='N/A')
                new_row['route_color'] = dataframeutility.optional_field(
                    i, 'route_color', self.static_feed['routes'],
                    default='FFFFFF').upper()
                new_row['route_text_color'] = dataframeutility.optional_field(
                    i, 'route_text_color', self.static_feed['routes'],
                    default='000000').upper()
                new_row['route_id'] = str(row['route_id'])
                new_row['version'] = self.checksum
                row_collector.append(new_row)

        dataframeutility.setup_table(table_name, self.datapath, self.routes_definition)
        self.generate_table(table_name, table, routes_row_func, typing,
                            refresh, rows=self.static_feed['routes'],
                            row_collector=row_collector)

    def stops_definition(self, metadata):
        return sa.Table(
            'Stops', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('stop_id', samysql.VARCHAR(255), nullable=False, primary_key=True),
            sa.Column('stop_code', samysql.VARCHAR(255), nullable=False, default='N/A'),
            sa.Column('stop_name', samysql.VARCHAR(255), nullable=False),
            sa.Column('stop_desc', samysql.VARCHAR(255), nullable=False, default='N/A'),
            sa.Column('stop_lat', samysql.DOUBLE(), nullable=False),
            sa.Column('stop_lon', samysql.DOUBLE(), nullable=False),
            sa.Column('stop_url', samysql.VARCHAR(255), nullable=False, default='N/A'),
            sa.Column('location_type', samysql.INTEGER(10, unsigned=True), nullable=False, default=0),
            sa.Column('parent_station', samysql.BIGINT(20), nullable=False, default=0),
            sa.Column('wheelchair_boarding', samysql.INTEGER(10, unsigned=True), nullable=False, default=0),
            sa.Column('version', samysql.VARCHAR(255), nullable=False, primary_key=True)
            )

    def stops(self, refresh=True):
        """Loads the Stops table into self.tables.

        Setups arguments for self.generate_table to match the description of
        the Stops table as described in Task 1.
        """
        table_name = 'Stops'
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'stop_id': samysql.VARCHAR(255),
                  'stop_code': samysql.VARCHAR(255),
                  'stop_name': samysql.VARCHAR(255),
                  'stop_desc': samysql.VARCHAR(255),
                  'stop_lat': samysql.DOUBLE(),
                  'stop_lon': samysql.DOUBLE(),
                  'stop_url': samysql.VARCHAR(255),
                  'location_type': samysql.INTEGER(10, unsigned=True),
                  'parent_station': samysql.BIGINT(20),
                  'wheelchair_boarding': samysql.INTEGER(10, unsigned=True),
                  'version': samysql.VARCHAR(255)
                  }
        table = pd.DataFrame(
            index=np.r_[0:len(self.static_feed['stops'].index)],
            columns=typing.keys())

        def stops_row_func(i, row):
            table.set_value(i, 'agency_id', int(self.agencyID))
            table.set_value(i, 'stop_id', str(row['stop_id']))
            table.set_value(i, 'stop_code', dataframeutility.optional_field(
                i, 'stop_code', self.static_feed['stops'], default='N/A'))
            table.set_value(i, 'stop_name', str(row['stop_name']))
            table.set_value(i, 'stop_desc', dataframeutility.optional_field(
                i, 'stop_desc', self.static_feed['stops'], default='N/A'))
            table.set_value(i, 'stop_lat', float(row['stop_lat']))
            table.set_value(i, 'stop_lon', float(row['stop_lon']))
            table.set_value(i, 'stop_url', dataframeutility.optional_field(
                i, 'stop_url', self.static_feed['stops'], default='N/A'))
            table.set_value(
                i, 'location_type', dataframeutility.optional_field(
                    i, 'location_type', self.static_feed['stops'], cast=int,
                    default=0))
            table.set_value(
                i, 'parent_station', dataframeutility.optional_field(
                    i, 'parent_station', self.static_feed['stops'], cast=int,
                    default=0))
            table.set_value(
                i, 'wheelchair_boarding', dataframeutility.optional_field(
                    i, 'wheelchair_boarding', self.static_feed['stops'],
                    cast=int, default=0))
            table.set_value(i, 'version', self.checksum)

        dataframeutility.setup_table(table_name, self.datapath, self.stops_definition)
        self.generate_table(table_name, table, stops_row_func, typing,
                            refresh, rows=self.static_feed['stops'])

    def trip_pattern_shape_definition(self, metadata):
        return sa.Table(
            'Trip_pattern_shape', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('trip_id', samysql.VARCHAR(255), nullable=False, primary_key=True),
            sa.Column('pattern_id', samysql.VARCHAR(255), nullable=False, primary_key=True),
            sa.Column('shape_id', samysql.VARCHAR(255), default='N/A'),
            )

    def trip_pattern_shape(self, refresh=True):
        """WIP

        WIP
        """
        table_name = 'Trip_pattern_shape'
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'trip_id': samysql.VARCHAR(255),
                  'pattern_id': samysql.VARCHAR(255),
                  'shape_id': samysql.VARCHAR(255)
                  }
        table = None
        row_collector = []

        def trip_pattern_shape_row_func(entity):
            new_row = {}
            new_row['agency_id'] = self.agencyID
            new_row['trip_id'] = entity[0]
            new_row['pattern_id'] = entity[1]
            new_row['shape_id'] = self.pattern2shape[entity[1]]
            row_collector.append(new_row)

        dataframeutility.setup_table(table_name, self.datapath, self.trip_pattern_shape_definition)
        self.generate_table(table_name, table, trip_pattern_shape_row_func, typing,
                            refresh, entities=self.trip2pattern.items(),
                            row_collector=row_collector)

        if not self.trip2pattern:
            self.trip2pattern = self.tables[table_name].set_index('trip_id')['pattern_id'].to_dict()
        if not self.pattern2shape:
            self.pattern2shape = self.tables[table_name].set_index('pattern_id')['shape_id'].to_dict()

    def route_stop_seq_definition(self, metadata):
        return sa.Table(
            'Route_stop_seq', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('route_short_name', samysql.VARCHAR(255), nullable=False, primary_key=True),
            sa.Column('route_dir', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('pattern_id', samysql.VARCHAR(255), nullable=False, primary_key=True),
            sa.Column('stop_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('seq', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('is_time_point', samysql.INTEGER(10, unsigned=True), nullable=False, default=0),
            sa.Column('version', samysql.VARCHAR(255), nullable=False, primary_key=True)
            )

    def route_stop_seq(self, refresh=True):
        """Loads the Route_stop_seq table into self.tables.

        Setups arguments for self.generate_table to match the description of
        the Route_stop_seq table as described in Task 1.
        """
        table_name = 'Route_stop_seq'
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'route_short_name': samysql.VARCHAR(255),
                  'route_dir': samysql.INTEGER(10, unsigned=True),
                  'pattern_id': samysql.VARCHAR(255),
                  'stop_id': samysql.VARCHAR(255),
                  'seq': samysql.INTEGER(10, unsigned=True),
                  'is_time_point': samysql.INTEGER(10, unsigned=True),
                  'version': samysql.VARCHAR(255)
                  }
        table = None
        row_collector = []

        # If a routeID has been given, fetch the rows in the routes table
        # pertaining to that route. Otherwise, use the whole routes table.

        if self.routeID is not None:
            route_rows = self.static_feed['routes'].loc[
                self.static_feed['routes'].route_id.apply(str) == self.routeID]
        else:
            route_rows = self.static_feed['routes']

        def route_stop_seq_row_func(i, row):
            route_id = row['route_id']
            patterns = []
            missing_shape_id = False
            new_pattern = False

            # Iterate through all the trips that run on a given route and
            # generate rows for each stop on those trips.

            for _, subrow in (self.static_feed['trips'].loc[
                    self.static_feed['trips']['route_id'] ==
                    route_id].iterrows()):
                trip_id = subrow['trip_id']
                direction_id = (subrow[
                    'direction_id'] if 'direction_id' in subrow else 0)
                # all the stops for a given trip_id
                trip_id_block = (self.static_feed['stop_times'].loc[
                    self.static_feed['stop_times']['trip_id'] == trip_id])

                # If a sequence of stops and its shape_id is unique, assign it
                # a new pattern_id. Otherwise fetch the existing pattern_id.

                sequence = trip_id_block['stop_id'].tolist()
                if 'shape_id' in subrow and not pd.isnull(subrow['shape_id']):
                    sequence.append(subrow['shape_id'])
                else:
                    missing_shape_id = True
                if str(sequence) not in patterns:
                    patterns += [str(sequence)]
                    new_pattern = True
                else:
                    new_pattern = False
                pattern_num = patterns.index(str(sequence)) + 1
                route_short_name = dataframeutility.optional_field(
                    i, 'route_short_name', self.static_feed['routes'],
                    default=(self.static_feed['routes'].iloc[i]
                             ['route_long_name']))
                pattern_id = "{0}_{1}_{2}".format(route_id, direction_id,
                                                  pattern_num)

                # Generate rows for each stop in on a trip for a given route.

                if new_pattern:
                    for k, subsubrow in trip_id_block.iterrows():
                        new_row = {}
                        new_row['agency_id'] = int(self.agencyID)
                        new_row['route_short_name'] = str(route_short_name)
                        new_row['route_dir'] = int(direction_id)
                        new_row['pattern_id'] = str(pattern_id)
                        new_row['stop_id'] = str(subsubrow['stop_id'])
                        new_row['seq'] = int(subsubrow['stop_sequence'])
                        new_row['is_time_point'] = (
                            dataframeutility.optional_field(
                                k, 'timepoint', self.static_feed['stop_times'],
                                cast=int, default=0)
                        )
                        new_row['version'] = self.checksum
                        row_collector.append(new_row)
                    self.pattern2shape[pattern_id] = (None if missing_shape_id
                                                      else subrow['shape_id'])
                self.trip2pattern[str(trip_id)] = pattern_id

        dataframeutility.setup_table(table_name, self.datapath, self.route_stop_seq_definition)
        self.generate_table(table_name, table, route_stop_seq_row_func, typing,
                            refresh, rows=route_rows,
                            row_collector=row_collector)

        self.trip_pattern_shape(refresh=refresh)

    def run_pattern_definition(self, metadata):
        return sa.Table(
            'RunPattern', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('route_short_name', samysql.VARCHAR(255), nullable=False, primary_key=True),
            sa.Column('start_date', samysql.DATE(), nullable=False, primary_key=True),
            sa.Column('end_date', samysql.DATE(), nullable=False),
            sa.Column('service_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('day', samysql.CHAR(7), nullable=False, primary_key=True),
            sa.Column('route_dir', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('run', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('pattern_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('trip_headsign', samysql.VARCHAR(255), nullable=False),
            sa.Column('trip_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('version', samysql.VARCHAR(255), nullable=False, primary_key=True)
            )

    def run_pattern(self, refresh=True):
        """Loads the RunPattern table into self.tables.

        Setups arguments for self.generate_table to match the description of
        the RunPattern table as described in Task 1.
        """
        table_name = 'RunPattern'
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'route_short_name': samysql.VARCHAR(255),
                  'start_date': samysql.DATE(),
                  'end_date': samysql.DATE(),
                  'service_id': samysql.VARCHAR(255),
                  'day': samysql.CHAR(7),
                  'route_dir': samysql.INTEGER(10, unsigned=True),
                  'run': samysql.INTEGER(10, unsigned=True),
                  'pattern_id': samysql.VARCHAR(255),
                  'trip_headsign': samysql.VARCHAR(255),
                  'trip_id': samysql.VARCHAR(255),
                  'version': samysql.VARCHAR(255)
                  }
        table = pd.DataFrame(
            index=np.r_[0:len(self.static_feed['trips'].index)],
            columns=typing.keys())

        if 'Route_stop_seq' not in self.tables:
            self.route_stop_seq(refresh=False)

        # If a routeID has been given, fetch the rows in the routes table
        # pertaining to that route. Otherwise, use the whole routes table.

        if self.routeID is not None:
            trip_rows = self.static_feed['trips'].loc[
                self.static_feed['trips'].route_id == self.routeID]
        else:
            trip_rows = self.static_feed['trips']

        run_count = {}

        def runPattern_row_func(i, row):
            table.set_value(i, 'agency_id', int(self.agencyID))
            # the index of the row containing the route
            j = np.where(self.static_feed['routes']['route_id'] ==
                         row['route_id'])[0][0]
            table.set_value(i, 'route_short_name',
                            dataframeutility.optional_field(
                                j, 'route_short_name',
                                self.static_feed['routes'],
                                default=(self.static_feed['routes'].iloc[j]
                                         ['route_long_name'])))
            table.set_value(i, 'service_id', str(row['service_id']))
            calendar = self.static_feed['calendar'].loc[self.static_feed[
                'calendar']['service_id'] == row['service_id']].iloc[0]
            table.set_value(i, 'start_date', datetime.strptime(
                str(calendar['start_date']), "%Y%m%d").strftime('%Y-%m-%d'))
            table.set_value(i, 'end_date', datetime.strptime(
                str(calendar['end_date']), "%Y%m%d").strftime('%Y-%m-%d'))
            table.set_value(i, 'day', '{0}{1}{2}{3}{4}{5}{6}'.format(
                calendar['monday'], calendar['tuesday'], calendar['wednesday'],
                calendar['thursday'], calendar['friday'], calendar['saturday'],
                calendar['sunday']))
            table.set_value(i, 'route_dir', dataframeutility.optional_field(
                i, 'direction_id', self.static_feed['trips'], cast=int,
                default=0))

            # For a given route, direction, operation days, and trip, enumerate
            # them starting from 1.

            run_key = '{0}_{1}_{2}'.format(
                self.static_feed['routes'].iloc[j]['route_id'],
                table.get_value(i, 'route_dir'), table.get_value(i, 'day'))
            if run_key not in run_count:
                run_count[run_key] = 1
            table.set_value(i, 'run', run_count[run_key])
            run_count[run_key] += 1

            table.set_value(i, 'pattern_id', str(self.trip2pattern[str(row['trip_id'])]))  # this will not work since you need to distinguish with agency_id
            table.set_value(i, 'trip_headsign',
                            dataframeutility.optional_field(
                                i, 'trip_headsign', self.static_feed['trips'],
                                default=(self.static_feed['stop_times'].loc[
                                         self.static_feed['stop_times']
                                         ['trip_id'] == row['trip_id']]
                                         ['stop_headsign'].iloc[0])))
            table.set_value(i, 'trip_id', str(row['trip_id']))
            table.set_value(i, 'version', self.checksum)

        dataframeutility.setup_table(table_name, self.datapath, self.run_pattern_definition)
        self.generate_table(table_name, table, runPattern_row_func, typing,
                            refresh, rows=trip_rows)

    def schedules_definition(self, metadata):
        return sa.Table(
            'Schedules', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('route_short_name', samysql.VARCHAR(255), nullable=False, primary_key=True, key='route_short_name'),
            sa.Column('start_date', samysql.DATE(), nullable=False, primary_key=True, key='start_date'),
            sa.Column('end_date', samysql.DATE(), nullable=False),
            sa.Column('day', samysql.CHAR(7), nullable=False, primary_key=True, key='day'),
            sa.Column('route_dir', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('run', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True, key='run'),
            sa.Column('pattern_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('seq', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('stop_id', samysql.VARCHAR(255), nullable=False, key='stop_id'),
            sa.Column('is_time_point', samysql.INTEGER(10, unsigned=True), nullable=False, default=0),
            sa.Column('pickup_type', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('dropoff_type', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('arrival_time', samysql.VARCHAR(10), nullable=False),
            sa.Column('departure_time', samysql.VARCHAR(10), nullable=False),
            sa.Column('stop_headsign', samysql.VARCHAR(255), nullable=False),
            sa.Column('trip_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('version', samysql.VARCHAR(255), nullable=False, primary_key=True)
            )

    def schedules(self, refresh=True):
        """Loads the Schedules table into self.tables.

        Setups arguments for self.generate_table to match the description of
        the Schedules table as described in Task 1.
        """
        table_name = 'Schedules'
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'route_short_name': samysql.VARCHAR(255),
                  'start_date': samysql.DATE(),
                  'end_date': samysql.DATE(),
                  'day': samysql.CHAR(7),
                  'route_dir': samysql.INTEGER(10, unsigned=True),
                  'run': samysql.INTEGER(10, unsigned=True),
                  'pattern_id': samysql.VARCHAR(255),
                  'seq': samysql.INTEGER(10, unsigned=True),
                  'stop_id': samysql.VARCHAR(255),
                  'is_time_point': samysql.INTEGER(10, unsigned=True),
                  'pickup_type': samysql.INTEGER(10, unsigned=True),
                  'dropoff_type': samysql.INTEGER(10, unsigned=True),
                  'arrival_time': samysql.VARCHAR(10),
                  'departure_time': samysql.VARCHAR(10),
                  'stop_headsign': samysql.VARCHAR(255),
                  'trip_id': samysql.VARCHAR(255),
                  'version': samysql.VARCHAR(255)
                  }
        table = pd.DataFrame(
            index=np.r_[0:len(self.static_feed['stop_times'].index)],
            columns=typing.keys())

        if 'Route_stop_seq' not in self.tables:
            self.route_stop_seq(refresh=False)
        if 'RunPattern' not in self.tables:
            self.run_pattern(refresh=False)

        trip_pattern_stop_count = {}
        runPattern_entry_memo = {}

        def schedules_row_func(i, row):
            # Since many rows will require the same data from the runPattern
            # table, this memoizes the entry needed based on the trip_id

            if row['trip_id'] not in runPattern_entry_memo:
                runPattern_entry_memo[row['trip_id']] = (
                    self.tables['RunPattern'].loc[
                        (self.tables['RunPattern']['trip_id'] ==
                         str(row['trip_id']))].iloc[0]
                )
            runPattern_entry = runPattern_entry_memo[row['trip_id']]
            table.set_value(i, 'agency_id', int(runPattern_entry['agency_id']))
            table.set_value(i, 'route_short_name',
                            str(runPattern_entry['route_short_name']))
            table.set_value(i, 'start_date', runPattern_entry['start_date'])
            table.set_value(i, 'end_date', runPattern_entry['end_date'])
            table.set_value(i, 'day', str(runPattern_entry['day']))
            table.set_value(i, 'route_dir', int(runPattern_entry['route_dir']))
            table.set_value(i, 'run', int(runPattern_entry['run']))
            table.set_value(i, 'pattern_id', str(runPattern_entry['pattern_id']))
            table.set_value(i, 'trip_id', str(runPattern_entry['trip_id']))
            table.set_value(i, 'version', runPattern_entry['version'])

            trip_pattern_stop = (str(runPattern_entry['trip_id']), 'pattern_id', str(runPattern_entry['pattern_id']), str(row['stop_id']))
            if trip_pattern_stop not in trip_pattern_stop_count:
                trip_pattern_stop_count[trip_pattern_stop] = 0
            else:
                trip_pattern_stop_count[trip_pattern_stop] += 1
            index = trip_pattern_stop_count[trip_pattern_stop]
            route_stop_seq_entry = (self.tables['Route_stop_seq'].loc[
                                   (self.tables['Route_stop_seq']['stop_id'] ==
                                    str(row['stop_id'])) & (self.tables['Route_stop_seq']['pattern_id'] == runPattern_entry['pattern_id'])].iloc[index])
            table.set_value(i, 'seq', int(route_stop_seq_entry['seq']))
            table.set_value(i, 'stop_id', str(route_stop_seq_entry['stop_id']))
            table.set_value(i, 'is_time_point',
                            int(route_stop_seq_entry['is_time_point']))
            table.set_value(i, 'pickup_type', dataframeutility.optional_field(
                i, 'pickup_type', self.static_feed['stop_times'], cast=int,
                default=0))
            table.set_value(i, 'dropoff_type', dataframeutility.optional_field(
                i, 'drop_off_type', self.static_feed['stop_times'], cast=int,
                default=0))
            table.set_value(i, 'arrival_time', str(row['arrival_time']))
            table.set_value(i, 'departure_time', str(row['departure_time']))
            table.set_value(i, 'stop_headsign',
                            dataframeutility.optional_field(
                                i, 'stop_headsign',
                                self.static_feed['stop_times'], default='N/A'))

        dataframeutility.setup_table(table_name, self.datapath, self.schedules_definition)
        self.generate_table(table_name, table, schedules_row_func, typing,
                            refresh, rows=self.static_feed['stop_times'])

    def route_point_seq_definition(self, metadata):
        return sa.Table(
            'Route_point_seq', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('route_short_name', samysql.VARCHAR(255), nullable=False),
            sa.Column('route_dir', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('pattern_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('shape_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('point_id', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('seq', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('length', samysql.DOUBLE(), nullable=False),
            sa.Column('heading', samysql.DOUBLE(), nullable=False),
            sa.Column('dist', samysql.DOUBLE(), nullable=False),
            sa.Column('version', samysql.VARCHAR(255), nullable=False)
            )

    def route_point_seq(self, refresh=True):
        """Loads the Route_point_seq table into self.tables (optional).

        Setups arguments for self.generate_table to match the description of
        the Route_point_seq table as described in Task 1.
        """
        table_name = 'Route_point_seq'
        if 'shapes' not in self.static_feed:
            logging.warning(('FAILURE could not compute {0} without the '
                             '\'{1}\' table').format(table_name, 'shapes'))
            self.tables[table_name] = None
            return
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'route_short_name': samysql.VARCHAR(255),
                  'route_dir': samysql.INTEGER(10, unsigned=True),
                  'pattern_id': samysql.VARCHAR(255),
                  'shape_id': samysql.VARCHAR(255),
                  'point_id': samysql.INTEGER(10, unsigned=True),
                  'seq': samysql.INTEGER(10, unsigned=True),
                  'length': samysql.DOUBLE(),
                  'heading': samysql.DOUBLE(),
                  'dist': samysql.DOUBLE(),
                  'version': samysql.VARCHAR(255)
                  }
        table = pd.DataFrame()
        row_collector = []

        if 'Route_stop_seq' not in self.tables:
            self.route_stop_seq(refresh=False)
        if 'Points' not in self.tables:
            self.points(refresh=False)

        pattern_id_log = []

        def route_point_seq_row_func(i, row):
            if row['pattern_id'] in pattern_id_log:
                return
            else:
                pattern_id_log.append(row['pattern_id'])

            shape_id = self.pattern2shape[row['pattern_id']]
            if shape_id is None:
                return

            shape_id_block = self.static_feed['shapes'].loc[self.static_feed['shapes']['shape_id'] == shape_id]

            last_point = None
            total_dist = 0
            for _, subrow in shape_id_block.iterrows():
                new_row = {}
                new_row['agency_id'] = int(row['agency_id'])
                new_row['route_short_name'] = str(row['route_short_name'])
                new_row['route_dir'] = int(row['route_dir'])
                new_row['pattern_id'] = str(row['pattern_id'])
                new_row['shape_id'] = str(shape_id)
                new_row['version'] = row['version']

                if self.tables['Points'] is not None:
                    points_entry = (self.tables['Points'].loc[
                                    (self.tables['Points']['point_lat'] ==
                                     subrow['shape_pt_lat']) &
                                    (self.tables['Points']['point_lon'] ==
                                     subrow['shape_pt_lon'])].iloc[0])
                else:
                    points_entry = {'point_id': None}
                new_row['point_id'] = int(points_entry['point_id'])

                new_row['seq'] = subrow['shape_pt_sequence'] + 1

                if last_point is None:
                    new_row['length'] = 0
                    total_dist = 0
                    new_row['heading'] = 0
                else:
                    new_row['length'] = maputility.get_distance(last_point[0], last_point[1], subrow['shape_pt_lat'], subrow['shape_pt_lon'])
                    total_dist += new_row['length']
                    new_row['heading'] = maputility.get_heading(last_point[0], last_point[1], subrow['shape_pt_lat'], subrow['shape_pt_lon'])
                new_row['dist'] = total_dist
                last_point = (subrow['shape_pt_lat'], subrow['shape_pt_lon'])
                row_collector.append(new_row)

        dataframeutility.setup_table(table_name, self.datapath, self.route_point_seq_definition)
        self.generate_table(table_name, table, route_point_seq_row_func,
                            typing, refresh,
                            rows=self.tables['Route_stop_seq'],
                            row_collector=row_collector)

    def points_definition(self, metadata):
        return sa.Table(
            'Points', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('point_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('point_lat', samysql.DOUBLE(), nullable=False),
            sa.Column('point_lon', samysql.DOUBLE(), nullable=False),
            sa.Column('version', samysql.VARCHAR(255), nullable=False, primary_key=True)
            )

    def points(self, refresh=True):
        """Loads the Points table into self.tables (optional).

        Setups arguments for self.generate_table to match the description of
        the Points table as described in Task 1.
        """
        table_name = 'Points'
        if 'shapes' not in self.static_feed:
            logging.warning(('FAILURE could not compute {0} without the'
                             '\'{1}\' table').format(table_name, 'shapes'))
            self.tables[table_name] = None
            return
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'point_id': samysql.INTEGER(10, unsigned=True),
                  'point_lat': samysql.DOUBLE(),
                  'point_lon': samysql.DOUBLE(),
                  'version': samysql.VARCHAR(255)
                  }
        table = None
        row_collector = []

        waypoints = []

        def points_row_func(i, row):
            new_row = {}

            waypoint = (row['shape_pt_lat'], row['shape_pt_lon'])
            if waypoint in waypoints:
                return
            else:
                waypoints.append(waypoint)

            new_row['agency_id'] = int(self.agencyID)
            new_row['point_id'] = int(waypoints.index(waypoint))
            new_row['point_lat'] = float(row['shape_pt_lat'])
            new_row['point_lon'] = float(row['shape_pt_lon'])
            new_row['version'] = self.checksum
            row_collector.append(new_row)

        dataframeutility.setup_table(table_name, self.datapath, self.points_definition)
        self.generate_table(table_name, table, points_row_func, typing,
                            refresh, rows=self.static_feed['shapes'],
                            row_collector=row_collector)

    def fare_definition(self, metadata):
        return sa.Table(
            'Fare', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('route_short_name', samysql.VARCHAR(255), nullable=False, primary_key=True),
            sa.Column('route_dir', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('pattern_id', samysql.VARCHAR(255), nullable=False, primary_key=True),
            sa.Column('price', samysql.DOUBLE(), nullable=False),
            sa.Column('currency_type', samysql.VARCHAR(255), nullable=False),
            sa.Column('payment_method', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('origin_id', samysql.INTEGER(11), nullable=False, default=-1, primary_key=True),
            sa.Column('destination_id', samysql.INTEGER(11), nullable=False, default=-1, primary_key=True),
            sa.Column('transfers', samysql.INTEGER(11), nullable=False, default=-1),
            sa.Column('transfer_duration', samysql.INTEGER(10, unsigned=True), nullable=False, default=0),
            sa.Column('fare_id', samysql.VARCHAR(45), nullable=False, default='Regular', primary_key=True),
            sa.Column('version', samysql.VARCHAR(255), nullable=False, primary_key=True)
            )

    def fare(self, refresh=True):
        """Loads the Fare table into self.tables (optional).

        Setups arguments for self.generate_table to match the description of
        the Fare table as described in Task 1.
        """
        table_name = 'Fare'
        if 'fare_rules' not in self.static_feed:
            logging.warning(
                ('FAILURE could not compute {0} without the '
                    '\'{1}\' table').format(table_name, 'fare_rules'))
            self.tables[table_name] = None
            return
        if 'fare_attributes' not in self.static_feed:
            logging.warning(
                ('FAILURE could not compute {0} without the'
                    '\'{1}\' table').format(table_name, 'fare_attributes'))
            self.tables[table_name] = None
            return
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'route_short_name': samysql.VARCHAR(255),
                  'route_dir': samysql.INTEGER(10, unsigned=True),
                  'pattern_id': samysql.VARCHAR(255),
                  'price': samysql.DOUBLE(),
                  'currency_type': samysql.VARCHAR(255),
                  'payment_method': samysql.INTEGER(10, unsigned=True),
                  'origin_id': samysql.INTEGER(11),
                  'destination_id': samysql.INTEGER(11),
                  'transfers': samysql.INTEGER(11),
                  'transfer_duration': samysql.INTEGER(10, unsigned=True),
                  'fare_id': samysql.VARCHAR(45),
                  'version': samysql.VARCHAR(255)
                  }
        table = pd.DataFrame()

        def fare_row_func(i, row):
            pass

        # dataframeutility.setup_table(table_name, self.datapath, self.fare_definition)
        # self.generate_table(table_name, table, fare_row_func, typing,
        #                     refresh, rows=self.static_feed['fare_rules'])

    def calendar_dates_definition(self, metadata):
        return sa.Table(
            'Calendar_dates', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('route_short_name', samysql.VARCHAR(255), nullable=False, primary_key=True),
            sa.Column('special_date', samysql.DATE(), nullable=False, primary_key=True, key='special_date'),
            sa.Column('route_dir', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('run', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('exception', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('day', samysql.CHAR(7), nullable=False, primary_key=True),
            sa.Column('service_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('version', samysql.VARCHAR(255), nullable=False, primary_key=True)
            )

    def calendar_dates(self, refresh=True):
        """Loads the Calendar_dates table into self.tables (optional).

        Setups arguments for self.generate_table to match the description of
        the Calendar_dates table as described in Task 1.
        """
        table_name = 'Calendar_dates'
        if 'calendar_dates' not in self.static_feed:
            logging.warning(
                ('FAILURE could not compute {0} without the '
                    '\'{1}\' table').format(table_name, 'calendar_dates'))
            self.tables[table_name] = None
            return
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'route_short_name': samysql.VARCHAR(255),
                  'special_date': samysql.DATE(),
                  'route_dir': samysql.INTEGER(10, unsigned=True),
                  'run': samysql.INTEGER(10, unsigned=True),
                  'exception': samysql.INTEGER(10, unsigned=True),
                  'day': samysql.CHAR(7),
                  'service_id': samysql.VARCHAR(255),
                  'version': samysql.VARCHAR(255)
                  }
        table = pd.DataFrame()

        def calendar_dates_row_func(i, row, lock=None):
            pass

        # dataframeutility.setup_table(table_name, self.datapath, self.calendar_dates_definition)
        # self.generate_table(table_name, table, calendar_dates_row_func, typing,
        #                     refresh, rows=self.static_feed['calendar_dates'])

    # MARK: TASK 2

    def transfers_definition(self, metadata):
        return sa.Table(
            'Transfers', metadata,
            sa.Column('from_agency_id', samysql.INTEGER(11), nullable=False, default=-1, primary_key=True),
            sa.Column('from_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('to_agency_id', samysql.INTEGER(11), nullable=False, default=-1, primary_key=True),
            sa.Column('to_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('transfer_type', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('min_transfer_time', samysql.INTEGER(10, unsigned=True), nullable=False),
            sa.Column('transfer_dist', samysql.INTEGER(11), nullable=False, default=0)
            )

    # TODO(erchpito) consider a function that merely finds all legal transfer
    # for a given stop via DataFrame calculation
    # make a function to check lat lon difference, OPTIMIZE THIS
    def transfers(self, refresh=True):
        """Loads the Transfers table into self.tables.

        Setups arguments for self.generate_table to match the description of
        the Transfers table as described in Task 2.
        """
        table_name = 'Transfers'
        typing = {'from_agency_id': samysql.INTEGER(11),
                  'from_id': samysql.INTEGER(10, unsigned=True),
                  'to_agency_id': samysql.INTEGER(11),
                  'to_id': samysql.INTEGER(10, unsigned=True),
                  'transfer_type': samysql.INTEGER(10, unsigned=True),
                  'min_transfer_time': samysql.INTEGER(10, unsigned=True),
                  'transfer_dist': samysql.INTEGER(11)
                  }
        table = None
        row_collector = []

        if 'Route_stop_seq' not in self.tables:
            self.route_stop_seq(refresh=False)

        max_distance = 100

        # TODO(erchpito) presume the given table is multimodal
        def transfers_row_func(i, row):
            pattern_id = row['pattern_id']
            from_agency = row['agency_id']
            from_stop_id = row['stop_id']
            from_stop_entry = self.static_feed['stops'].loc[
                self.static_feed['stops']['stop_id'] == from_stop_id].iloc[0]
            from_stop_point = (
                from_stop_entry['stop_lat'], from_stop_entry['stop_lon'])

            # Retrieve all the entries in Route_stop_seq which have a different
            # pattern_id than the that of the row's.

            for _, subrow in (self.tables['Route_stop_seq'].loc[
                              self.tables['Route_stop_seq']['pattern_id'] !=
                              pattern_id].iterrows()):
                to_agency = subrow['agency_id']
                to_stop_id = subrow['stop_id']
                # TODO(erchpito) this does not work since these stops can be
                # from other agencies this would be the only calculation that
                # would have to search through the static GTFS feeds of other
                # agencies find mapping from stop_id to agency generate
                # intraagency and interagency indepedently
                to_stop_entry = self.static_feed['stops'].loc[
                    self.static_feed['stops']['stop_id'] == to_stop_id].iloc[0]
                to_stop_point = (
                    to_stop_entry['stop_lat'], to_stop_entry['stop_lon'])

                (transfer_dist, min_transfer_time) = (
                    maputility.get_distance_and_time(
                        from_stop_point[0], from_stop_point[1],
                        to_stop_point[0], to_stop_point[1])
                )
                if transfer_dist > max_distance:
                    continue
                else:
                    new_row = {}
                    new_row['from_agency_id'] = from_agency
                    new_row['from_id'] = from_stop_id
                    new_row['to_agency_id'] = to_agency
                    new_row['to_id'] = to_stop_id

                    transfer_type = 0

                    # If trasnfer_type and min_transfer_time can be read from
                    # the transfers table, then it should be used.

                    if ('transfers' in self.static_feed and
                       from_agency == to_agency):
                        transfers_entry = (
                            self.static_feed['transfers'].loc[
                                (self.static_feed['transfers']['from_stop_id']
                                    == from_stop_id) &
                                (self.static_feed['transfers']['to_stop_id'] ==
                                    to_stop_id)]
                        )
                        other_transfers_entry = (
                            self.static_feed['transfers'].loc[
                                (self.static_feed['transfers']['from_stop_id']
                                    == to_stop_id) &
                                (self.static_feed['transfers']['to_stop_id'] ==
                                    from_stop_id)]
                        )
                        if not transfers_entry.empty:
                            transfer_type = transfers_entry.iloc[
                                0]['transfer_type']
                            min_transfer_time = (
                                dataframeutility.optional_field(
                                    0, 'min_transfer_time', transfers_entry,
                                    cast=int, default=min_transfer_time)
                            )
                        elif not other_transfers_entry.empty:
                            transfer_type = other_transfers_entry.iloc[
                                0]['transfer_type']
                            min_transfer_time = (
                                dataframeutility.optional_field(
                                    0, 'min_transfer_time',
                                    other_transfers_entry, cast=int,
                                    default=min_transfer_time)
                            )

                    new_row['transfer_type'] = tranfer_type
                    new_row['min_transfer_time'] = min_transfer_time
                    new_row['transfer_dist'] = transfer_dist
                    row_collector.append(new_row)

        dataframeutility.setup_table(table_name, self.datapath, self.transfers_definition)
        self.generate_table(table_name, table, transfers_row_func, typing,
                            refresh, rows=self.tables['Route_stop_seq'],
                            row_collector=row_collector)

    # MARK: TASK 3

    def gps_fixes_definition(self, metadata):
        return sa.Table(
            'gps_fixes', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('veh_id', samysql.INTEGER(11), nullable=False, primary_key=True, key='veh_id'),
            sa.Column('RecordedDate', samysql.DATE(), nullable=False, primary_key=True, key='RecordedDate'),
            sa.Column('RecordedTime', samysql.TIME(), nullable=False, primary_key=True),
            sa.Column('UTC_at_date', samysql.DATE(), nullable=False),
            sa.Column('UTC_at_time', samysql.TIME(), nullable=False),
            sa.Column('latitude', samysql.DOUBLE(), nullable=False),
            sa.Column('longitude', samysql.DOUBLE(), nullable=False),
            sa.Column('speed', samysql.DOUBLE(), nullable=False),
            sa.Column('course', samysql.DOUBLE(), nullable=False)
            )

    def gps_fixes(self, refresh=True):
        """Loads the gps_fixes table into self.tables (optional).

        Setups arguments for self.generate_table to match the description of
        the gps_fixes table as described in Task 3.
        """
        table_name = 'gps_fixes'
        if (self.vehicle_position_feed is None or
           not self.vehicle_position_feed.entity):
            logging.warning(('FAILURE could not compute {0} without the '
                             '\'{1}\' feed').format(table_name,
                                                    'vehicle positions'))
            self.tables[table_name] = None
            return
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'veh_id': samysql.INTEGER(11),
                  'RecordedDate': samysql.DATE(),
                  'RecordedTime': samysql.TIME(),
                  'UTC_at_date': samysql.DATE(),
                  'UTC_at_time': samysql.TIME(),
                  'latitude': samysql.DOUBLE(),
                  'longitude': samysql.DOUBLE(),
                  'speed': samysql.DOUBLE(),
                  'course': samysql.DOUBLE()
                  }
        table = None
        row_collector = []

        def gps_fixes_row_func(entity):
            update = gtfsutility.VehiclePosition(entity.vehicle)
            trip = update.get_trip_descriptor()
            position = update.get_position()
            vehicle = update.get_vehicle_descriptor()
            misc = update.get_update_fields()

            new_row = {}
            new_row['agency_id'] = self.agencyID
            new_row['veh_id'] = int(vehicle['id'] if (
                vehicle and 'id' in vehicle) else -1)
            new_row['RecordedDate'] = str(datetime.now().strftime('%Y-%m-%d'))
            new_row['RecordedTime'] = str(datetime.now().strftime('%H:%M:%S'))
            # TODO(erchpito) there are timestamps in the VTA set but for
            # whatever reason they're not read correctly
            timestamp = datetime.fromtimestamp(int(misc['timestamp'])) if (
                misc and 'timestamp' in misc) else -1
            new_row['UTC_at_date'] = str(timestamp.strftime(
                '%Y-%m-%d') if (timestamp == -1) else 'N/A')
            new_row['UTC_at_time'] = str(timestamp.strftime(
                '%H:%M:%S') if (timestamp == -1) else 'N/A')
            new_row['latitude'] = float(position['latitude'] if (
                position and 'latitude' in position) else -1)
            new_row['longitude'] = float(position['longitude'] if (
                position and 'longitude' in position) else -1)
            new_row['speed'] = float(position['speed'] if (
                position and 'speed' in position) else -1)
            new_row['course'] = float(position['bearing'] if (
                position and 'bearing' in position) else -1)
            row_collector.append(new_row)

            # TODO(erchpito) figure out what to do with this
            if (trip and 'trip_id' in trip) and (vehicle and 'id' in vehicle):
                self.trip2vehicle[trip['trip_id']] = vehicle['id']

        dataframeutility.setup_table(table_name, self.datapath, self.gps_fixes_definition)
        self.generate_table(table_name, table, gps_fixes_row_func, typing,
                            refresh,
                            entities=self.vehicle_position_feed.entity,
                            row_collector=row_collector)

    def transit_eta_definition(self, metadata):
        return sa.Table(
            'TransitETA', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('RecordedDate', samysql.DATE(), nullable=False, primary_key=True, key='RecordedDate'),
            sa.Column('RecordedTime', samysql.TIME(), nullable=False, primary_key=True),
            sa.Column('veh_id', samysql.INTEGER(11), nullable=False, primary_key=True),
            sa.Column('veh_lat', samysql.DOUBLE(), nullable=False),
            sa.Column('veh_lon', samysql.DOUBLE(), nullable=False),
            sa.Column('veh_speed', samysql.DOUBLE(), nullable=False),
            sa.Column('veh_location_time', samysql.BIGINT(20), nullable=False),
            sa.Column('route_short_name', samysql.VARCHAR(255), nullable=False, primary_key=True, key='route_short_name'),
            sa.Column('route_dir', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('day', samysql.CHAR(7), nullable=False, primary_key=True),
            sa.Column('run', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('pattern_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('stop_id', samysql.VARCHAR(255), nullable=False, key='stop_id'),
            sa.Column('seq', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('ETA', samysql.TIME(), nullable=False, primary_key=True)
            )

    # TODO(erchpito) how do we handle situations where the vehicle corrects
    # itself? do we update the entire table to reflect it caught up?
    def transit_eta(self, refresh=True):
        """Loads the TransitETA table into self.tables.

        Setups arguments for self.generate_table to match the description of
        the TransitETA table as described in Task 3.
        """
        table_name = 'TransitETA'
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'RecordedDate': samysql.DATE(),
                  'RecordedTime': samysql.TIME(),
                  'veh_id': samysql.INTEGER(11),
                  'veh_lat': samysql.DOUBLE(),
                  'veh_lon': samysql.DOUBLE(),
                  'veh_speed': samysql.DOUBLE(),
                  'veh_location_time': samysql.BIGINT(20),
                  'route_short_name': samysql.VARCHAR(255),
                  'route_dir': samysql.INTEGER(10, unsigned=True),
                  'day': samysql.CHAR(7),
                  'run': samysql.INTEGER(10, unsigned=True),
                  'pattern_id': samysql.VARCHAR(255),
                  'stop_id': samysql.VARCHAR(255),
                  'seq': samysql.INTEGER(10, unsigned=True),
                  'ETA': samysql.TIME()
                  }
        table = None
        row_collector = []

        if 'RunPattern' not in self.tables:
            self.run_pattern(refresh=False)
        if 'gps_fixes' not in self.tables:
            self.gps_fixes(refresh=False)

        def transit_eta_row_func(entity):
            update = gtfsutility.TripUpdate(entity.trip_update)
            trip_descriptor = update.get_trip_descriptor()
            stop_time_updates = update.get_stop_time_updates()

            trip_id = str(trip_descriptor['trip_id'])
            runPattern_entry = self.tables['RunPattern'].loc[
                self.tables['RunPattern']['trip_id'] == trip_id].iloc[0]

            if self.tables['gps_fixes'] is not None:
                # TODO(erchpito) trip_update can include the veh_id, not always
                # an int
                veh_id = int(self.trip2vehicle[trip_id])
                gps_fixes_entry = self.tables['gps_fixes'].loc[
                    self.tables['gps_fixes']['veh_id'] == veh_id].iloc[0]
                s = datetime.strptime(
                    '{0} {1}'.format(
                        gps_fixes_entry['UTC_at_date'],
                        gps_fixes_entry['UTC_at_time']),
                    '%Y-%m-%d %H:%M:%S')
                timestamp = time.mktime(s.timetuple())
            else:
                gps_fixes_entry = {}
                gps_fixes_entry['veh_id'] = 0
                gps_fixes_entry['veh_lat'] = 0
                gps_fixes_entry['veh_lon'] = 0
                gps_fixes_entry['veh_speed'] = 0
                timestamp = 0

            # Given a Trip Update, find and iterate through the stops along
            # that trip, starting with the ith stop in the first Stop Time
            # Update.

            trip_id_block = self.static_feed['stop_times'].loc[
                self.static_feed['stop_times']['trip_id'].apply(str) == trip_id]
            i = 0
            while i < len(stop_time_updates):
                stop_time_update = stop_time_updates[i]
                if ('departure' in stop_time_update or
                   'arrival' in stop_time_update):
                    stop_seq = stop_time_update['stop_sequence']
                    stop_seq_til = (stop_time_updates[i + 1]['stop_sequence']
                                    if i + 1 < len(stop_time_updates) else
                                    len(trip_id_block) + 1)

                    time_diff = stop_time_update[('departure' if 'departure' in
                                                 stop_time_update else
                                                 'arrival')]

                    if 'delay' in time_diff:
                        delay = timedelta(seconds=time_diff['delay'])
                    else:  # it would seem this is stop_sequence specific
                        delay_time = datetime.fromtimestamp(
                            int(time_diff['time']))
                        schedule_time = self.datetimeFromHMS(
                            trip_id_block.iloc[stop_seq - 1]['departure_time'])
                        delay = delay_time - schedule_time

                    # this would ignore all stops until there's a delay
                    while stop_seq < stop_seq_til:
                        stop_times_entry = trip_id_block.iloc[stop_seq - 1]
                        new_row = {}
                        new_row['agency_id'] = int(self.agencyID)
                        new_row['RecordedDate'] = str(
                            datetime.now().strftime('%Y-%m-%d'))
                        new_row['RecordedTime'] = str(
                            datetime.now().strftime('%H:%M:%S'))

                        new_row['veh_id'] = gps_fixes_entry['veh_id']
                        new_row['veh_lat'] = gps_fixes_entry['veh_lat']
                        new_row['veh_lon'] = gps_fixes_entry['veh_lon']
                        new_row['veh_speed'] = gps_fixes_entry['veh_speed']
                        new_row['veh_location_time'] = timestamp

                        new_row['route_short_name'] = str(runPattern_entry['route_short_name'])
                        new_row['route_dir'] = int(runPattern_entry['route_dir'])
                        new_row['day'] = str(runPattern_entry['day'])
                        new_row['run'] = int(runPattern_entry['run'])
                        new_row['pattern_id'] = str(runPattern_entry['pattern_id'])

                        new_row['stop_id'] = str(stop_times_entry['stop_id'])
                        new_row['seq'] = int(stop_seq)
                        new_row['ETA'] = (self.datetimeFromHMS(
                                          stop_times_entry['departure_time']) +
                                          delay).strftime('%H:%M:%S')
                        row_collector.append(new_row)
                        stop_seq += 1
                i += 1

        dataframeutility.setup_table(table_name, self.datapath, self.transit_eta_definition)
        self.generate_table(table_name, table, transit_eta_row_func, typing,
                            refresh, entities=self.trip_update_feed.entity,
                            row_collector=row_collector)

    def transit_eta_bart_definition(self, metadata):
        return sa.Table(
            'TransitETABART', metadata,
            sa.Column('agency_id', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('RecordedDate', samysql.DATE(), nullable=False, primary_key=True, key='RecordedDate'),
            sa.Column('RecordedTime', samysql.TIME(), nullable=False, primary_key=True),
            sa.Column('route_short_name', samysql.VARCHAR(255), nullable=False, primary_key=True, key='route_short_name'),
            sa.Column('route_dir', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('day', samysql.CHAR(7), nullable=False, primary_key=True),
            sa.Column('run', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('pattern_id', samysql.VARCHAR(255), nullable=False),
            sa.Column('stop_id', samysql.VARCHAR(255), nullable=False, key='stop_id'),
            sa.Column('seq', samysql.INTEGER(10, unsigned=True), nullable=False, primary_key=True),
            sa.Column('ETA', samysql.TIME(), nullable=False, primary_key=True),
            sa.Column('STA', samysql.TIME(), nullable=False, primary_key=True),
            )

    def transit_eta_bart(self, refresh=True):
        """Loads the TransitETABART table into self.tables.

        Setups arguments for self.generate_table to match the description of
        the TransitETA table as described in Task 3. However, this table is
        dedicated to logging BART Trip Update feeds, without replacement.
        """
        table_name = 'TransitETABART'
        typing = {'agency_id': samysql.INTEGER(10, unsigned=True),
                  'RecordedDate': samysql.DATE(),
                  'RecordedTime': samysql.TIME(),
                  'route_short_name': samysql.VARCHAR(255),
                  'route_dir': samysql.INTEGER(10, unsigned=True),
                  'day': samysql.CHAR(7),
                  'run': samysql.INTEGER(10, unsigned=True),
                  'pattern_id': samysql.VARCHAR(255),
                  'stop_id': samysql.VARCHAR(255),
                  'seq': samysql.INTEGER(10, unsigned=True),
                  'ETA': samysql.TIME(),
                  'STA': samysql.TIME()
                  }
        table = None
        row_collector = []

        if 'RunPattern' not in self.tables:
            self.run_pattern(refresh=False)
        if 'gps_fixes' not in self.tables:
            self.gps_fixes(refresh=False)

        def transit_eta_bart_row_func(entity):
            update = gtfsutility.TripUpdate(entity.trip_update)
            trip_descriptor = update.get_trip_descriptor()
            stop_time_updates = update.get_stop_time_updates()

            trip_id = str(trip_descriptor['trip_id'])
            runPattern_entry = self.tables['RunPattern'].loc[
                self.tables['RunPattern']['trip_id'] == trip_id].iloc[0]

            # Given a Trip Update, find and iterate through the stops along
            # that trip, starting with the ith stop in the first Stop Time
            # Update.

            trip_id_block = self.static_feed['stop_times'].loc[
                self.static_feed['stop_times']['trip_id'].apply(str) == trip_id]
            i = 0
            no_delay = timedelta(seconds=0)
            while i < len(stop_time_updates):
                stop_time_update = stop_time_updates[i]
                if ('departure' in stop_time_update or 'arrival' in stop_time_update):
                    stop_seq = stop_time_update['stop_sequence']
                    stop_seq_til = (stop_time_updates[i + 1]['stop_sequence'] if i + 1 < len(stop_time_updates) else len(trip_id_block) + 1)

                    time_diff = stop_time_update[('departure' if 'departure' in stop_time_update else 'arrival')]

                    if 'delay' in time_diff:
                        delay = timedelta(seconds=time_diff['delay'])
                    else:  # it would seem this is stop_sequence specific
                        delay_time = datetime.fromtimestamp(int(time_diff['time']))
                        schedule_time = self.datetimeFromHMS(trip_id_block.iloc[stop_seq - 1]['departure_time'])
                        delay = delay_time - schedule_time

                    # don't add entries if there's no delay
                    if delay == no_delay:
                        stop_seq = stop_seq_til
                        i += 1
                        continue

                    while stop_seq < stop_seq_til:
                        stop_times_entry = trip_id_block.iloc[stop_seq - 1]
                        new_row = {}
                        new_row['agency_id'] = int(self.agencyID)
                        new_row['RecordedDate'] = str(
                            datetime.now().strftime('%Y-%m-%d'))
                        new_row['RecordedTime'] = str(
                            datetime.now().strftime('%H:%M:%S'))

                        new_row['route_short_name'] = str(runPattern_entry['route_short_name'])
                        new_row['route_dir'] = int(runPattern_entry['route_dir'])
                        new_row['day'] = str(runPattern_entry['day'])
                        new_row['run'] = int(runPattern_entry['run'])
                        new_row['pattern_id'] = str(runPattern_entry['pattern_id'])

                        new_row['stop_id'] = str(stop_times_entry['stop_id'])
                        new_row['seq'] = int(stop_seq)
                        new_row['ETA'] = (self.datetimeFromHMS(stop_times_entry['departure_time']) + delay).strftime('%H:%M:%S')
                        new_row['STA'] = stop_times_entry['departure_time']
                        row_collector.append(new_row)
                        stop_seq += 1
                i += 1

        dataframeutility.setup_table(table_name, self.datapath, self.transit_eta_bart_definition)
        self.generate_table(table_name, table, transit_eta_bart_row_func, typing,
                            refresh, entities=self.trip_update_feed.entity,
                            row_collector=row_collector, clear=False)
